# Домашнее задание к занятию "6.6. Troubleshooting"

## Задача 1

Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB](https://docs.mongodb.com/manual/administration/).

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её 
нужно прервать. 

Вы как инженер поддержки решили произвести данную операцию:
- напишите список операций, которые вы будете производить для остановки запроса пользователя
- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

### Ответ

* Если пользователь запустил какую то операцию, которая длится слишком долго и мы принимаем решение прервать её, то предполагается следующая последовательность действий:
1. Сначала надо найти идентификатор этой операции `opid`. 
Это можно сделать при помощи команды: `currentOp`, которая возвращает документ, содержащий данные обо всех, выполняющихся в данный момент операциях в БД, как пользовательских так и системных. При этом синтаксис команды предполагает различную фильтрацию при поиске, поэтому зная, какой пользователь запустил операцию и ещё какие-то её признаки (тип и т.д.), можно найти `opid` именно нужной операции. Документация [тут](https://docs.mongodb.com/v4.4/reference/command/currentOp/).
2. Затем необходимо прервать выполнение, указав найденный идентификатор. 
Это делается с помощью метода `db.killOp(<opId>)`, как описано [тут](https://docs.mongodb.com/manual/tutorial/terminate-running-operations/#killop).

* В случае если в MongoDB зависают запросы, то вероятно придётся воспользоваться механизмом прерывания выполнения долгих запросов.
Для этого используется метод `maxTimeMS`, который описан [тут](https://docs.mongodb.com/manual/tutorial/terminate-running-operations/#maxtimems).
При этом задаётся разрешённое время выполнения операции. Если операция затянулась дольше указанного времени происходит её автоматическое прерывание. 

## Задача 2

Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и
увеличивается пропорционально количеству реплик сервиса. 

При масштабировании сервиса до N реплик вы увидели, что:
- сначала рост отношения записанных значений к истекшим
- Redis блокирует операции записи

Как вы думаете, в чем может быть проблема?

### Ответ 
 
## Задача 3

Перед выполнением задания познакомьтесь с документацией по [Common Mysql errors](https://dev.mysql.com/doc/refman/8.0/en/common-errors.html).

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы,
пользователи начали жаловаться на ошибки вида:
```python
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```

Как вы думаете, почему это начало происходить и как локализовать проблему?

Какие пути решения данной проблемы вы можете предложить?

### Ответ
Изучив этот [раздел](https://dev.mysql.com/doc/refman/8.0/en/error-lost-connection.html)
Можно предположить, что в процессе выполнения SELECT, происходит выборка очень большого объёма данных и, как следствие его выполнение занимает больше времени, чем значение параметра `net_write_timeout` ([описание](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_net_read_timeout)). Его дефолтное значение =30 сек. То есть через 30 сек. происходит принудительное отключение клиентского соединения.

В качестве возможных путей решения этой проблемы можно предложить следующие:
- Самый очевидный способ - увеличить значение, указанного параметра. Возможно данные успеют передаться если он будет больше. 
- Более сложный, но концептуально более правильный - пересмотреть какие данные запрашиваются запросом SELECT. Возможно стоит сузить количество данных, разбив "объёмные" запросы на запросы поменьше.

## Задача 4

Перед выполнением задания ознакомтесь со статьей [Common PostgreSQL errors](https://www.percona.com/blog/2020/06/05/10-common-postgresql-errors/) из блога Percona.

Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с 
большим объемом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

`postmaster invoked oom-killer`

Как вы думаете, что происходит?

Как бы вы решили данную проблему?

### Ответ
Вообще `oom-killer` - это процесс, который запускается, если в системе заканчивается свободная память. Он вбирает, какой процесс убить и, возможно иногда убивает `postgres`, потому, что он потребляет больше всего памяти.

В качестве решений можно предложить такие:
- отключить  `oom-killer` в системе. Но этого делать не рекомендуется.
- ограничить `postgres` в объёме потребляемой памяти так, чтобы даже если он заберёт себе всё, что мы указали, в системе  ещё оставалась память для работы других процессов и `oom-killer` не запускался. Ну к примеру если на сервере 16Гб памяти, то ограничить `postgres` до 10Гб, а остальное останется для других процессов.

---
